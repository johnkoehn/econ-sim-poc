use crate::tiles::TileAccount;
use anchor_lang::{prelude::*};

use super::GameAccount;

// calculate the number of resources generated by a tile by tile level
// every ten levels is special
pub fn calculate_resources_per_cycle(level: u8) -> u64 {
    let level_power = (level / 10) as u32;

    ((12 * level) as u64) * (2 as u64).pow(level_power)
}

pub fn calculate_max_capacity(level: u8, cycles_per_period: i32) -> u64 {
    // resource calculation per cycle
    let resources_per_cycle = calculate_resources_per_cycle(level);

    resources_per_cycle * cycles_per_period as u64
}

// calculates the new capacity and returns new capacity and timestamp
pub fn calculate_capacity(tile_account: &TileAccount, game_account: &GameAccount) -> (u64, i64) {
    let level = tile_account.level;
    let cycles_per_period = game_account.cycles_per_period;

    let seconds_passed = (Clock::get().unwrap().unix_timestamp - tile_account.last_cycle_time) as u64;
    let cycles_passed = seconds_passed / (game_account.cycle_time as u64);

    let added_capacity = cycles_passed * calculate_resources_per_cycle(level);
    let max_capacity = calculate_max_capacity(level, cycles_per_period);
    let new_capacity = tile_account.capacity + added_capacity;

    let actual_capacity = if new_capacity > max_capacity { max_capacity } else { new_capacity };
    let new_cycle_time= tile_account.last_cycle_time + (cycles_passed as i64 * (game_account.cycle_time as i64));

    (actual_capacity, new_cycle_time)
}

pub fn get_current_cycle_time(game_account: &GameAccount) -> i64 {
    let seconds_passed = (Clock::get().unwrap().unix_timestamp - game_account.start_time) as u64;
    let cycles_passed = seconds_passed / (game_account.cycle_time as u64);

    return game_account.start_time + (cycles_passed as i64 * (game_account.cycle_time as i64));
}